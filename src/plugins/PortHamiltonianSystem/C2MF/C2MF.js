/**
* Generated by PluginGenerator from webgme on Tue Jun 10 2014 17:42:32 GMT-0500 (Central Daylight Time).
*/

define(['plugin/PluginConfig',
        'plugin/PluginBase',
        'plugin/C2MF/C2MF/meta'], function (PluginConfig, PluginBase, MetaTypes) {
    'use strict';

    /**
    * Initializes a new instance of C2MF.
    * @class
    * @augments {PluginBase}
    * @classdesc This class represents the plugin C2MF.
    * @constructor
    */
    var C2MF = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.metaTypes = MetaTypes;
    };

    // Prototypal inheritance from PluginBase.
    C2MF.prototype = Object.create(PluginBase.prototype);
    C2MF.prototype.constructor = C2MF;

    /**
    * Gets the name of the C2MF.
    * @returns {string} The name of the plugin.
    * @public
    */
    C2MF.prototype.getName = function () {
        return "Component2MatlabFile";
    };

    /**
    * Gets the semantic version (semver.org) of the C2MF.
    * @returns {string} The version of the plugin.
    * @public
    */
    C2MF.prototype.getVersion = function () {
        return "0.1.0";
    };

    /**
    * Gets the description of the C2MF.
    * @returns {string} The description of the plugin.
    * @public
    */
    C2MF.prototype.getDescription = function () {
        return "Generate a Matlab m-file from a Component";
    };

    /**
    * Main function for the plugin to execute. This will perform the execution.
    * Notes:
    * - Always log with the provided logger.[error,warning,info,debug].
    * - Do NOT put any user interaction logic UI, etc. inside this method.
    * - callback always has to be called even if error happened.
    *
    * @param {function(string, plugin.PluginResult)} callback - the result callback
    */
    C2MF.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            mFileString,
            mFileName,
            getComponentInfoCallback,
            resultArtifact,
            generatedFilesToAdd = {},
            addFilesCallback;

        self.updateMETA(self.metaTypes);

        if (self.isMetaTypeOf(self.activeNode, MetaTypes.Component) === false) {
            self.createMessage(self.activeNode, 'SelectedNode is not a Component!');
            return callback(null, self.result);
        }

        getComponentInfoCallback = function (err, componentInfo) {
            if (err) {
                self.result.setSuccess(false);
                var msg = 'Failed to get component info from ' + self.core.getName(self.activeNode);
                self.createMessage(self.activeNode, msg);
                return callback(err, self.result);
            }

            mFileString = self.buildMatlabScript(componentInfo);
            mFileName = componentInfo.name + '.m';

            generatedFilesToAdd[mFileName] = mFileString;

            resultArtifact = self.blobClient.createArtifact(componentInfo.name);

            addFilesCallback = function (err, fileHashes) {
                if (err) {
                    self.result.setSuccess(false);
                    self.createMessage(self.activeNode, 'Failed to add files to result artifact.');
                    return callback(err, self.result);
                }

                var artifactSaveCallback = function (err, artifactHash) {
                    if (err) {
                        self.result.setSuccess(false);
                        self.createMessage(self.activeNode, 'Failed to save result artifact.');
                        return callback(err, self.result);
                    }

                    self.result.setSuccess(true);
                    self.createMessage(self.activeNode, 'Generated .m-file for ' + componentInfo.name);
                    self.result.addArtifact(artifactHash);
                    callback(null, self.result);
                };

                resultArtifact.save(artifactSaveCallback);
            }

            resultArtifact.addFiles(generatedFilesToAdd, addFilesCallback);
        };

        self.getComponentInfo(self.activeNode, getComponentInfoCallback);
    };

    C2MF.prototype.buildMatlabScript = function (componentInfo) {
        var self = this,
            mFileString = '',
            nodePath,
            itemNumber = 1,
            element,
            propertyName,
            propertyValue,
            bond;

        for (nodePath in componentInfo.elements) {
            element = componentInfo.elements[nodePath];

            mFileString += '% element(' + itemNumber + ') WebGmePath = ' + nodePath;
            mFileString += '\n';

            for (propertyName in element) {
                propertyValue = element[propertyName];

                if (propertyName === 'Bond') {
                    mFileString += 'element(' + itemNumber + ').' + propertyName + ' = [\'';
                    mFileString += propertyValue.join('\',\'');
                    mFileString += '\'];';
                } else if (typeof propertyValue === 'number') {
                    mFileString += 'element(' + itemNumber + ').' + propertyName + ' = ' + propertyValue + ';';
                } else {
                    mFileString += 'element(' + itemNumber + ').' + propertyName + ' = \'' + propertyValue + '\';';
                }

                mFileString += '\n';
            }

            itemNumber += 1;
            mFileString += '\n';
        }

        itemNumber = 1;

        for (nodePath in componentInfo.bonds) {
            bond = componentInfo.bonds[nodePath];

            mFileString += '% bond(' + itemNumber + ') WebGmePath = ' + nodePath;
            mFileString += '\n';
            mFileString += 'bond(' + itemNumber + ').ID = \'' + bond.ID + '\';';
            mFileString += '\n';
            mFileString += 'bond(' + itemNumber + ').src = \'' + bond.src + '\';';
            mFileString += '\n';
            mFileString += 'bond(' + itemNumber + ').dst = \'' + bond.dst + '\';';

            itemNumber += 1;
            mFileString += '\n\n';
        }

        return mFileString;
    };

    C2MF.prototype.createNewElementObject = function () {
        return {
            ID: '',
            Name: '',
            Type: '',
            Equation: 'N/A',
            Ratio: 0,
            Bond: []
        };
    };

    C2MF.prototype.getComponentInfo = function (componentNode, callback) {
        var self = this,
            childNode,
            nodePath,
            nodeGuid,
            metaTypeNode,
            metaTypeName,
            loadChildrenCallbackFunction,
            bondNodes = [],
            elementObject,
            bondObject,
            bondSrcNodePath,
            bondDstNodePath,
            path2elementMap = {},
            path2bondMap = {},
            i;

        loadChildrenCallbackFunction = function (err, children) {
            if (err) {
                callback(err, null);
            }

            for (i = 0; i < children.length; i += 1) {
                childNode = children[i];
                metaTypeNode = self.getMetaType(childNode);
                metaTypeName = self.core.getAttribute(metaTypeNode, 'name');

                if (self.isMetaTypeOf(childNode, self.metaTypes.ComponentConnection)) {
                    // defer bond nodes; handle them after element node info is complete
                    bondNodes.push(childNode);
                } else {
                    nodePath = self.core.getPath(childNode);
                    nodeGuid = self.core.getGuid(childNode);

                    elementObject = self.createNewElementObject();
                    elementObject.ID = self.core.getGuid(childNode);
                    elementObject.Name = self.core.getAttribute(childNode, 'name');
                    elementObject.Type = metaTypeName;

                    if (metaTypeNode === self.metaTypes.ControlPort ||
                        metaTypeNode === self.metaTypes.ResistivePort ||
                        metaTypeNode === self.metaTypes.StoragePort) {
                        elementObject.Equation = self.core.getAttribute(childNode, 'Equation');
                    }
                    if (metaTypeNode === self.metaTypes.Gyrator ||
                        metaTypeNode === self.metaTypes.Transformer) {
                        elementObject.Ratio = parseFloat(self.core.getAttribute(childNode, 'Ratio'));
                    }

                    path2elementMap[nodePath] = elementObject;
                }
            }

            for (i = 0; i < bondNodes.length; i += 1) {
                childNode = bondNodes[i];

                nodePath = self.core.getPath(childNode);
                nodeGuid = self.core.getGuid(childNode);
                bondSrcNodePath = self.core.getPointerPath(childNode, 'src');
                bondDstNodePath = self.core.getPointerPath(childNode, 'dst');

                bondObject = {};

                bondObject.ID = nodeGuid;

                if (path2elementMap.hasOwnProperty(bondSrcNodePath)) {
                    path2elementMap[bondSrcNodePath].Bond.push(nodeGuid);
                    bondObject.src = path2elementMap[bondSrcNodePath].ID;
                } else {
                    bondObject.src = 'error: ' + bondSrcNodePath;
                }

                if (path2elementMap.hasOwnProperty(bondDstNodePath)) {
                    path2elementMap[bondDstNodePath].Bond.push(nodeGuid);
                    bondObject.dst = path2elementMap[bondDstNodePath].ID;
                } else {
                    bondObject.dst = 'error: ' + bondDstNodePath;
                }

                path2bondMap[nodePath] = bondObject;
            }

            callback(null, {
                name: self.core.getAttribute(componentNode, 'name'),
                elements: path2elementMap,
                bonds: path2bondMap
            });
        };

        self.core.loadChildren(componentNode, loadChildrenCallbackFunction);
    };

    return C2MF;
});